
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="all" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="https://blog.davep.org/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="https://blog.davep.org/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="https://blog.davep.org/theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/static/davep.css">

  <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">


  <link href="https://blog.davep.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="blog.davep.org Atom">

  <link href="https://blog.davep.org/feed.xml" type="application/rss+xml" rel="alternate" title="blog.davep.org RSS">







 

<meta name="author" content="Dave Pearson" />
<meta name="description" content="It&#39;s been very quiet on the blogging front, I&#39;m afraid, mostly for the reasons I wrote about back in December last year. In that time I&#39;ve been really very busy with work (in a good way, in a very good way) and there&#39;s not a whole lot of time to be toying with pet projects at home. However, finding myself with a spare hour or so, I wanted to write about something I did run into as part of some development at work, and which I thought might be worth writing about in case it helps someone else. Recently I&#39;ve needed to write a library of code for loading data from Excel Workbooks. Given that the vast majority of coding I do at the moment is in Python, it made sense to make use of openpyxl. The initial prototype code I wrote worked well and it soon grew into a full-blown library that&#39;ll be used in a couple of work-related projects. But one thing kept niggling me... It just wasn&#39;t as fast as I&#39;d expected. The workbooks I&#39;m pulling data from aren&#39;t that large, and yet it was taking a noticeable number of seconds to read in the data, and when I let the code have a go at a directory full of such workbooks... even the fan on the machine would ramp up. It didn&#39;t seem right. I did a little bit of profiling and could see that the code was spending most of its time deep in the guts of some XML-parsing functions. While I know that an xlsx file is pretty much an XML document, it seemed odd to me that it would take so much time and effort to pull the data out from it. Given that I had other code to be writing, and given that the workbook-parsing code was &#34;good enough&#34; for the moment, I moved on for a short while. But, a couple of weeks back, I had a bit of spare time and decided to revisit it. I did some more searching on openpyxl and speed issues and almost everything I found said that the common problem was failing to open the workbook in read_only mode. That can&#39;t have been my problem because I&#39;d being doing that from the very start. Eventually I came across a post somewhere (sorry, I&#39;ve lost it for now -- I&#39;ll try and track it down again) that suggested that openpyxl was very slow to read from a workbook if you were reading one cell at a time, rather than using generators. The suggestion being that every time you pull a value form a cell, it has to parse the whole sheet up to that cell. Generators, on the other hand, would allow access to all the cells during one parse. This seemed a little unlikely to me -- I&#39;d have expected the code to cache the parsing results or something like that -- but it also would explain what I was seeing. So I decided to give it a test. openpyxl-speed-issue is a version of the tests I wrote and ran and they absolutely show that there&#39;s a huge difference between cell-by-cell access vs generator access. Code like this: for row in range( 1, sheet.max_row + 1 ): for col in range( 0, sheet.max_column ): value = sheet[ row ][ col ].value is far slower than something like this: for row in wb[ &#34;Test Sheet&#34; ].rows: for cell in row: value = cell.value Here&#39;s an example of the difference in time, as seen on my iMac: $ make test pipenv run time ./read-using-generators 1.59 real 0.44 user 0.04 sys pipenv run time ./read-using-peeking 25.02 real 24.88 user 0.10 sys As you can see, the cell-by-cell approach is about 16 times slower than the generator approach. In most circumstances the generator approach would make most sense anyway, and in any other situation I probably would have used it and never have noticed this. However, the nature of the workbooks I need to pull data from means I need to &#34;peek ahead&#34; to make decisions about what I&#39;m doing, so a more traditional loop over, with an index, made more sense. I can easily &#34;fix&#34; this by using the generator approach to build up a two-dimensional array of cells, acquired via the generator; so I can still do what I want and benefit from using generators. In conclusion: given that I found it difficult to find information about my speed issue, and given that the one off-hand comment I saw that suggested it was this wasn&#39;t exactly easy to find, I thought I&#39;d write it all down too and create a repository of some test code to illustrate the issue. Hopefully someone else will benefit from this in the future." />
<meta name="keywords" content="Python, openpyxl">


  <meta property="og:site_name" content="blog.davep.org"/>
  <meta property="og:title" content="A little speed issue with openpyxl"/>
  <meta property="og:description" content="It&#39;s been very quiet on the blogging front, I&#39;m afraid, mostly for the reasons I wrote about back in December last year. In that time I&#39;ve been really very busy with work (in a good way, in a very good way) and there&#39;s not a whole lot of time to be toying with pet projects at home. However, finding myself with a spare hour or so, I wanted to write about something I did run into as part of some development at work, and which I thought might be worth writing about in case it helps someone else. Recently I&#39;ve needed to write a library of code for loading data from Excel Workbooks. Given that the vast majority of coding I do at the moment is in Python, it made sense to make use of openpyxl. The initial prototype code I wrote worked well and it soon grew into a full-blown library that&#39;ll be used in a couple of work-related projects. But one thing kept niggling me... It just wasn&#39;t as fast as I&#39;d expected. The workbooks I&#39;m pulling data from aren&#39;t that large, and yet it was taking a noticeable number of seconds to read in the data, and when I let the code have a go at a directory full of such workbooks... even the fan on the machine would ramp up. It didn&#39;t seem right. I did a little bit of profiling and could see that the code was spending most of its time deep in the guts of some XML-parsing functions. While I know that an xlsx file is pretty much an XML document, it seemed odd to me that it would take so much time and effort to pull the data out from it. Given that I had other code to be writing, and given that the workbook-parsing code was &#34;good enough&#34; for the moment, I moved on for a short while. But, a couple of weeks back, I had a bit of spare time and decided to revisit it. I did some more searching on openpyxl and speed issues and almost everything I found said that the common problem was failing to open the workbook in read_only mode. That can&#39;t have been my problem because I&#39;d being doing that from the very start. Eventually I came across a post somewhere (sorry, I&#39;ve lost it for now -- I&#39;ll try and track it down again) that suggested that openpyxl was very slow to read from a workbook if you were reading one cell at a time, rather than using generators. The suggestion being that every time you pull a value form a cell, it has to parse the whole sheet up to that cell. Generators, on the other hand, would allow access to all the cells during one parse. This seemed a little unlikely to me -- I&#39;d have expected the code to cache the parsing results or something like that -- but it also would explain what I was seeing. So I decided to give it a test. openpyxl-speed-issue is a version of the tests I wrote and ran and they absolutely show that there&#39;s a huge difference between cell-by-cell access vs generator access. Code like this: for row in range( 1, sheet.max_row + 1 ): for col in range( 0, sheet.max_column ): value = sheet[ row ][ col ].value is far slower than something like this: for row in wb[ &#34;Test Sheet&#34; ].rows: for cell in row: value = cell.value Here&#39;s an example of the difference in time, as seen on my iMac: $ make test pipenv run time ./read-using-generators 1.59 real 0.44 user 0.04 sys pipenv run time ./read-using-peeking 25.02 real 24.88 user 0.10 sys As you can see, the cell-by-cell approach is about 16 times slower than the generator approach. In most circumstances the generator approach would make most sense anyway, and in any other situation I probably would have used it and never have noticed this. However, the nature of the workbooks I need to pull data from means I need to &#34;peek ahead&#34; to make decisions about what I&#39;m doing, so a more traditional loop over, with an index, made more sense. I can easily &#34;fix&#34; this by using the generator approach to build up a two-dimensional array of cells, acquired via the generator; so I can still do what I want and benefit from using generators. In conclusion: given that I found it difficult to find information about my speed issue, and given that the one off-hand comment I saw that suggested it was this wasn&#39;t exactly easy to find, I thought I&#39;d write it all down too and create a repository of some test code to illustrate the issue. Hopefully someone else will benefit from this in the future."/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://blog.davep.org/2018/06/02/a_little_speed_issue_with_openpyxl.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2018-06-02 13:16:37+01:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://blog.davep.org/author/dave-pearson.html">
  <meta property="article:section" content="Python"/>
  <meta property="article:tag" content="Python"/>
  <meta property="article:tag" content="openpyxl"/>
  <meta property="og:image" content="/static/davep.jpeg">

  <title>blog.davep.org &ndash; A little speed issue with openpyxl</title>


</head>
<body >

<aside>
  <div>
    <a href="https://blog.davep.org/">
      <img src="/static/davep.jpeg" alt="davep" title="davep">
    </a>

    <h1>
      <a href="https://blog.davep.org/">davep</a>
    </h1>

    <p>Code, Emacs, VR, Stuff...</p>


    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://blog.davep.org/pages/about.html#about">
                About
              </a>
            </li>
            <li>
              <a target="_blank"
                 href="https://blog.davep.org/pages/dot-files.html#dot-files">
                Dot Files
              </a>
            </li>

          <li>
            <a target="_blank" href="http://davep.at/" >davep@</a>
          </li>
          <li>
            <a target="_blank" href="https://raindrop.io/davep/public-46742255/sort=-created&perpage=30&page=0" >Bookmarks</a>
          </li>
          <li>
            <a target="_blank" href="https://seenbydavep.blogspot.com/" >Photoblog</a>
          </li>
          <li>
            <a target="_blank" href="https://elisp.dev/" >Emacs Packages</a>
          </li>
          <li>
            <a target="_blank" href="https://pypi.org/user/davepearson/" >Python Packages</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="https://github.com/davep"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-mastodon"
rel="me"           href="https://fosstodon.org/@davep"
           target="_blank">
          <i class="fa-brands fa-mastodon"></i>
        </a>
      </li>
      <li>
        <a class="sc-flickr"
           href="https://www.flickr.com/photos/davepearson/"
           target="_blank">
          <i class="fa-brands fa-flickr"></i>
        </a>
      </li>
      <li>
        <a class="sc-lastfm"
           href="https://www.last.fm/user/davepdotorg"
           target="_blank">
          <i class="fa-brands fa-lastfm"></i>
        </a>
      </li>
      <li>
        <a class="sc-npm"
           href="https://www.npmjs.com/~davep.org"
           target="_blank">
          <i class="fa-brands fa-npm"></i>
        </a>
      </li>
      <li>
        <a class="sc-youtube"
           href="https://www.youtube.com/user/daveporg"
           target="_blank">
          <i class="fa-brands fa-youtube"></i>
        </a>
      </li>
      <li>
        <a class="sc-steam"
           href="https://steamcommunity.com/id/davepdotorg"
           target="_blank">
          <i class="fa-brands fa-steam"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://blog.davep.org/">Home</a>

  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://blog.davep.org/feeds/all.atom.xml">Atom</a>

  <a href="https://blog.davep.org/feed.xml">RSS</a>
</nav>

<article class="single">
  <header>
      
    <h1 id="a_little_speed_issue_with_openpyxl">A little speed issue with openpyxl</h1>
    <p>
      Posted on 2018-06-02 13:16 +0100 in <a href="https://blog.davep.org/category/python.html">Python</a>

        &#8226; 4 min read
    </p>
  </header>


  <div>
    <p>It's been very quiet on the blogging front, I'm afraid, mostly for <a href="/2017/12/12/on_to_something_new.html">the
reasons I wrote about back in December last
year</a>. In that time I've been really
very busy with work (in a good way, in a <em>very</em> good way) and there's not a
whole lot of time to be toying with pet projects at home.</p>
<p>However, finding myself with a spare hour or so, I wanted to write about
something I did run into as part of some development at work, and which I
thought might be worth writing about in case it helps someone else.</p>
<p>Recently I've needed to write a library of code for loading data from Excel
Workbooks. Given that the vast majority of coding I do at the moment is in
Python, it made sense to make use of
<a href="https://openpyxl.readthedocs.io/">openpyxl</a>. The initial prototype code I
wrote worked well and it soon grew into a full-blown library that'll be used
in a couple of work-related projects.</p>
<p>But one thing kept niggling me... It just wasn't as fast as I'd expected.
The workbooks I'm pulling data from aren't that large, and yet it was taking
a noticeable number of seconds to read in the data, and when I let the code
have a go at a directory full of such workbooks... even the fan on the
machine would ramp up.</p>
<p>It didn't seem right.</p>
<p>I did a little bit of profiling and could see that the code was spending
most of its time deep in the guts of some XML-parsing functions. While I
know that an <code>xlsx</code> file is pretty much an XML document, it seemed odd to me
that it would take so much time and effort to pull the data out from it.</p>
<p>Given that I had other code to be writing, and given that the
workbook-parsing code was "good enough" for the moment, I moved on for a
short while.</p>
<p>But, a couple of weeks back, I had a bit of spare time and decided to
revisit it. I did some more searching on openpyxl and speed issues and
almost everything I found said that the common problem was failing to open
the workbook in <code>read_only</code> mode. That can't have been my problem because
I'd being doing that from the very start.</p>
<p>Eventually I came across a post somewhere (sorry, I've lost it for now --
I'll try and track it down again) that suggested that openpyxl was very slow
to read from a workbook if you were reading one cell at a time, rather than
using generators. The suggestion being that every time you pull a value form
a cell, it has to parse the whole sheet up to that cell. Generators, on the
other hand, would allow access to all the cells during one parse.</p>
<p>This seemed a little unlikely to me -- I'd have expected the code to cache
the parsing results or something like that -- but it also would explain what
I was seeing. So I decided to give it a test.</p>
<p><a href="https://github.com/davep/openpyxl-speed-issue"><code>openpyxl-speed-issue</code></a> is a
version of the tests I wrote and ran and they absolutely show that there's a
huge difference between cell-by-cell access vs generator access.</p>
<p>Code like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sheet</span><span class="o">.</span><span class="n">max_row</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sheet</span><span class="o">.</span><span class="n">max_column</span> <span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sheet</span><span class="p">[</span> <span class="n">row</span> <span class="p">][</span> <span class="n">col</span> <span class="p">]</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>

<p>is <em>far slower</em> than something like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">wb</span><span class="p">[</span> <span class="s2">&quot;Test Sheet&quot;</span> <span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>

<p>Here's an example of the difference in time, as seen on my iMac:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>make<span class="w"> </span><span class="nb">test</span>
pipenv<span class="w"> </span>run<span class="w"> </span><span class="nb">time</span><span class="w"> </span>./read-using-generators
<span class="w">        </span><span class="m">1</span>.59<span class="w"> </span>real<span class="w">         </span><span class="m">0</span>.44<span class="w"> </span>user<span class="w">         </span><span class="m">0</span>.04<span class="w"> </span>sys
pipenv<span class="w"> </span>run<span class="w"> </span><span class="nb">time</span><span class="w"> </span>./read-using-peeking
<span class="w">       </span><span class="m">25</span>.02<span class="w"> </span>real<span class="w">        </span><span class="m">24</span>.88<span class="w"> </span>user<span class="w">         </span><span class="m">0</span>.10<span class="w"> </span>sys
</code></pre></div>

<p>As you can see, the cell-by-cell approach is about 16 times slower than the
generator approach.</p>
<p>In most circumstances the generator approach would make most sense anyway,
and in any other situation I probably would have used it and never have
noticed this. However, the nature of the workbooks I need to pull data from
means I need to "peek ahead" to make decisions about what I'm doing, so a
more traditional loop over, with an index, made more sense.</p>
<p>I can easily "fix" this by using the generator approach to build up a
two-dimensional array of cells, acquired via the generator; so I can still
do what I want <em>and</em> benefit from using generators.</p>
<p>In conclusion: given that I found it difficult to find information about my
speed issue, and given that the one off-hand comment I saw that suggested it
was this wasn't exactly easy to find, I thought I'd write it all down too
and <a href="https://github.com/davep/openpyxl-speed-issue">create a repository of some test code to illustrate the
issue</a>. Hopefully someone
else will benefit from this in the future.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://blog.davep.org/tag/python.html">Python</a>
      <a href="https://blog.davep.org/tag/openpyxl.html">openpyxl</a>
    </p>
  </div>



  <div class="neighbors">
    <a class="btn float-left" href="https://blog.davep.org/2017/12/12/on_to_something_new.html" title="On to something new">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://blog.davep.org/2019/10/18/time-to-move-on.html" title="Time to move on">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>




</article>

<footer>
<p>&copy; 2015-2026 Dave Pearson</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://blog.davep.org/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " blog.davep.org ",
  "url" : "https://blog.davep.org",
  "image": "/static/davep.jpeg",
  "description": ""
}
</script>
</body>
</html>