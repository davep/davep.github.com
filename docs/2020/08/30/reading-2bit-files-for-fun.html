
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="all" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
    href="https://blog.davep.org/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark), (prefers-color-scheme: no-preference)"
          href="https://blog.davep.org/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light)"
          href="https://blog.davep.org/theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="https://blog.davep.org/static/davep.css">

  <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">


  <link href="https://blog.davep.org/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="blog.davep.org Atom">

  <link href="https://blog.davep.org/feed.xml" type="application/rss+xml" rel="alternate" title="blog.davep.org RSS">







 

<meta name="author" content="Dave Pearson" />
<meta name="description" content="Introduction I&#39;ve written a bit before about the value of having simple but interesting &#34;problems&#34;, that you know the solution to, as a way of exercising yourself in a new environment. Recently I&#39;ve added another to the list I already have, and I used it as an excuse to get back into writing some Common Lisp; and then went on to use it as a reason to write yet another package for Emacs. Having gone through the process of writing code to handle 2bit files twice in about a month, and in two very similar but slightly different languages, I thought it might be interesting for me to then use it to exercise my ability to write blog posts (something I always struggle with -- I find writing very hard on a number of levels) and especially posts that explain a particular problem and how I implemented code relating to that problem. Also, because the initial version of this post rambled on a bit too much and I lost the ability to finish it, I&#39;m starting again and will be breaking it up a number of posts spanning a number of days -- perhaps even weeks -- so that I don&#39;t feel too overwhelmed by the process of writing it. I will, of course, make sure every post links to the other posts. Now, before I go on, I&#39;ll make the important point that everything here is written from the perspective of a software developer who happens to work as part of a bioinformatics team; I don&#39;t do bioinformatics, I don&#39;t claim to understand it, I just happen to sit with (well, used to sit with them -- hopefully we&#39;ll all make it back to the office one day!) and work with them, and develop software that supports their work. Anything you see in any of the posts that&#39;s wrong about that subject: that&#39;s just my ignorance being shown through the lens of a software developer (all corrections are welcome). So, with all those disclaimers aside, I&#39;m going to go on a slow wander through what a 2bit file is, how you&#39;d go about reading it, and related issues. This isn&#39;t designed as a tutorial or anything like that, this is simply me taking what I&#39;ve learnt and writing it down. Perhaps someone else will benefit one day, but the purpose is to simply enjoy cementing it in my own mind and to enjoy the process of putting it all in writing. What is a &#34;2bit file&#34;? So what&#39;s this new &#34;problem&#34; I&#39;ve added to my list? It&#39;s code to read sequence data from 2bit format files. For anyone who doesn&#39;t know (bioinformatics people look away now; a software developer is going to explain one of your file formats), this is a file format that is intended to hold sequences in an efficient way. As I&#39;m sure you know, DNA is made up of 4 bases, represented by the letters T, C, A and G. So, in the simplest case, we could just represent a genome using those four letters. Simple enough, right? Nice big text file with just those 4 letters in? The thing is, something like the human genome is around 3 billion bases in length. That&#39;d make for a petty big file to have to store and move around. So why not compress it down a bit? That&#39;s where the 2bit format comes in. Given this problem I&#39;m sure most developers would quickly notice that, given 4 different characters, you only need 2 bits to actually hold them all (two bits gets us 00, 01, 10 and 11, so four different states). This means with a little bit of coding you can store 4 bases in a single byte. Just like that you&#39;ve pretty much squished the whole thing down to 1/4 of the original size. And that&#39;s more or less what the 2bit format does. If you take a look at the actual data for the human genome you&#39;ll see that hg38.2bit is roughly 1/4 of 3 billion bytes, ish, give or take. There is a wrinkle, however. There are parts of a genome where you might not know what base is there. Generally an N is used for that. So, actually, we want to be able to store 5 different characters. But 5 isn&#39;t going to go into 2 bits... Damn! Well, it&#39;s okay, 2bit has a solution to that too, and I&#39;ll cover that later on. How is a 2bit file formatted? As you can see from the format information available online, a 2bit file is a binary file format that is split into 3 key parts: A fixed size header with some key information An index into the rest of the file A series of records that contain actual sequence information In this first post I&#39;ll cover the details of the header. Subsequent posts will cover the index and the actual sequence data records. The header The header of a 2bit file is fixed in size and contains some key information. It can be broken down as follows: Content Type Size Comments Signature Integer 4 bytes See below for endian issues. Version Integer 4 bytes Always 0. Sequence count Integer 4 bytes Reserved Integer 4 bytes Always ignored. The signature value is used to test if what you&#39;re looking at is a 2bit file, but also tells you some vital information about how to read the file -- see below for more on that. The version value is always 0 -- as such another useful test would be to error out if you get a valid signature but get a version other than 0. The sequence count is, as you&#39;d guess, the number of sequences that are held within the file -- this is important when loading in the index of the file (more on that in the next post). The signature, big and little endianness, and byte swapping The header mentioned above comprises of 4 32-bit word values. The very first word is important to how you read the rest of the file. This is the signature for the 2bit file and it should always be 0x1A412743. And this is where it gets interesting and fun right away. The 2bit file format allows for the fact that the file can be built in either a little-endian or a big-endian machine, and the 32-bit word values can be binary-written to the file in the local architecture&#39;s byte order. The effect of this is that, from reading the very first value in the file, you need to decide if every other numeric value you read needs to be byte-swapped in some way. The early logic being (in no particular language) something like: if signature == 0x1A412743 then must_swap = False else if byte_swap( signature ) == 0x1A412743 then must_swap = True else raise &#34;This isn&#39;t a valid 2bit file&#34; end Simply put, to read the rest of the file you will need a function that byte-swaps a 32bit numeric value, and a flag of some sort to mark that you need to do this every time you read such a value. Of course, depending on your language of choice, you could do it in a number of different ways. In a language like JavaScript or Scheme, where you can easily throw around functions, I&#39;d probably just assign the appropriate 32bit-word-reading function to a global function name and call that regardless throughout the rest of the code. In other languages I&#39;d probably just check the flag each time and call the swapping function if needed. In something like Python I&#39;d likely just use the signature to decide on which format to pass to struct.unpack. For example, some variation on: # Assuming that &#39;header&#39; is the whole header of the file read as a binary buffer. word_fmt = &#34;&#34; for test_fmt in ( &#34;&lt;I&#34;, &#34;&gt;I&#34; ): if struct.unpack( test_fmt, header[ 0:4 ] )[ 0 ] == 0x1A412743 word_fmt = test_fmt break if not word_fmt: raise Exception( &#34;This isn&#39;t a 2bit file&#34; ) Now, the Python approach sort of hides the important detail here. With it we&#39;d simply use struct.unpack&#39;s ability to handle different byte orders and not worry about the detail. Which isn&#39;t fun, right? So how might code to byte-swap a 32bit value look? Assuming you&#39;ve got the value as an actual numeric integer, it can be as simple as using a bit of bitwise anding and shifting. Here&#39;s the basic code I wrote in Common Lisp, for example: (defun swap-long (value) &#34;Swap the endianness of a long integer VALUE.&#34; (logior (logand (ash value -24) #xff) (logand (ash value -8) #xff00) (logand (ash value 8) #xff0000) (logand (ash value 24) #xff000000))) JavaScript might be something like: function swapLong( value ) { return ( ( value &gt;&gt; 24 ) &amp; 0xff ) | ( ( value &gt;&gt; 8 ) &amp; 0xff00 ) | ( ( value &lt;&lt; 8 ) &amp; 0xff0000 ) | ( ( value &lt;&lt; 24 ) &amp; 0xff000000 ) } and other variations on that theme in different languages. Up next In the next post I&#39;ll write about how the sequence index is stored and how to load it, including some considerations about how to make the loading as efficient as possible." />
<meta name="keywords" content="Bioinformatics">


  <meta property="og:site_name" content="blog.davep.org"/>
  <meta property="og:title" content="Reading 2bit files (for fun)"/>
  <meta property="og:description" content="Introduction I&#39;ve written a bit before about the value of having simple but interesting &#34;problems&#34;, that you know the solution to, as a way of exercising yourself in a new environment. Recently I&#39;ve added another to the list I already have, and I used it as an excuse to get back into writing some Common Lisp; and then went on to use it as a reason to write yet another package for Emacs. Having gone through the process of writing code to handle 2bit files twice in about a month, and in two very similar but slightly different languages, I thought it might be interesting for me to then use it to exercise my ability to write blog posts (something I always struggle with -- I find writing very hard on a number of levels) and especially posts that explain a particular problem and how I implemented code relating to that problem. Also, because the initial version of this post rambled on a bit too much and I lost the ability to finish it, I&#39;m starting again and will be breaking it up a number of posts spanning a number of days -- perhaps even weeks -- so that I don&#39;t feel too overwhelmed by the process of writing it. I will, of course, make sure every post links to the other posts. Now, before I go on, I&#39;ll make the important point that everything here is written from the perspective of a software developer who happens to work as part of a bioinformatics team; I don&#39;t do bioinformatics, I don&#39;t claim to understand it, I just happen to sit with (well, used to sit with them -- hopefully we&#39;ll all make it back to the office one day!) and work with them, and develop software that supports their work. Anything you see in any of the posts that&#39;s wrong about that subject: that&#39;s just my ignorance being shown through the lens of a software developer (all corrections are welcome). So, with all those disclaimers aside, I&#39;m going to go on a slow wander through what a 2bit file is, how you&#39;d go about reading it, and related issues. This isn&#39;t designed as a tutorial or anything like that, this is simply me taking what I&#39;ve learnt and writing it down. Perhaps someone else will benefit one day, but the purpose is to simply enjoy cementing it in my own mind and to enjoy the process of putting it all in writing. What is a &#34;2bit file&#34;? So what&#39;s this new &#34;problem&#34; I&#39;ve added to my list? It&#39;s code to read sequence data from 2bit format files. For anyone who doesn&#39;t know (bioinformatics people look away now; a software developer is going to explain one of your file formats), this is a file format that is intended to hold sequences in an efficient way. As I&#39;m sure you know, DNA is made up of 4 bases, represented by the letters T, C, A and G. So, in the simplest case, we could just represent a genome using those four letters. Simple enough, right? Nice big text file with just those 4 letters in? The thing is, something like the human genome is around 3 billion bases in length. That&#39;d make for a petty big file to have to store and move around. So why not compress it down a bit? That&#39;s where the 2bit format comes in. Given this problem I&#39;m sure most developers would quickly notice that, given 4 different characters, you only need 2 bits to actually hold them all (two bits gets us 00, 01, 10 and 11, so four different states). This means with a little bit of coding you can store 4 bases in a single byte. Just like that you&#39;ve pretty much squished the whole thing down to 1/4 of the original size. And that&#39;s more or less what the 2bit format does. If you take a look at the actual data for the human genome you&#39;ll see that hg38.2bit is roughly 1/4 of 3 billion bytes, ish, give or take. There is a wrinkle, however. There are parts of a genome where you might not know what base is there. Generally an N is used for that. So, actually, we want to be able to store 5 different characters. But 5 isn&#39;t going to go into 2 bits... Damn! Well, it&#39;s okay, 2bit has a solution to that too, and I&#39;ll cover that later on. How is a 2bit file formatted? As you can see from the format information available online, a 2bit file is a binary file format that is split into 3 key parts: A fixed size header with some key information An index into the rest of the file A series of records that contain actual sequence information In this first post I&#39;ll cover the details of the header. Subsequent posts will cover the index and the actual sequence data records. The header The header of a 2bit file is fixed in size and contains some key information. It can be broken down as follows: Content Type Size Comments Signature Integer 4 bytes See below for endian issues. Version Integer 4 bytes Always 0. Sequence count Integer 4 bytes Reserved Integer 4 bytes Always ignored. The signature value is used to test if what you&#39;re looking at is a 2bit file, but also tells you some vital information about how to read the file -- see below for more on that. The version value is always 0 -- as such another useful test would be to error out if you get a valid signature but get a version other than 0. The sequence count is, as you&#39;d guess, the number of sequences that are held within the file -- this is important when loading in the index of the file (more on that in the next post). The signature, big and little endianness, and byte swapping The header mentioned above comprises of 4 32-bit word values. The very first word is important to how you read the rest of the file. This is the signature for the 2bit file and it should always be 0x1A412743. And this is where it gets interesting and fun right away. The 2bit file format allows for the fact that the file can be built in either a little-endian or a big-endian machine, and the 32-bit word values can be binary-written to the file in the local architecture&#39;s byte order. The effect of this is that, from reading the very first value in the file, you need to decide if every other numeric value you read needs to be byte-swapped in some way. The early logic being (in no particular language) something like: if signature == 0x1A412743 then must_swap = False else if byte_swap( signature ) == 0x1A412743 then must_swap = True else raise &#34;This isn&#39;t a valid 2bit file&#34; end Simply put, to read the rest of the file you will need a function that byte-swaps a 32bit numeric value, and a flag of some sort to mark that you need to do this every time you read such a value. Of course, depending on your language of choice, you could do it in a number of different ways. In a language like JavaScript or Scheme, where you can easily throw around functions, I&#39;d probably just assign the appropriate 32bit-word-reading function to a global function name and call that regardless throughout the rest of the code. In other languages I&#39;d probably just check the flag each time and call the swapping function if needed. In something like Python I&#39;d likely just use the signature to decide on which format to pass to struct.unpack. For example, some variation on: # Assuming that &#39;header&#39; is the whole header of the file read as a binary buffer. word_fmt = &#34;&#34; for test_fmt in ( &#34;&lt;I&#34;, &#34;&gt;I&#34; ): if struct.unpack( test_fmt, header[ 0:4 ] )[ 0 ] == 0x1A412743 word_fmt = test_fmt break if not word_fmt: raise Exception( &#34;This isn&#39;t a 2bit file&#34; ) Now, the Python approach sort of hides the important detail here. With it we&#39;d simply use struct.unpack&#39;s ability to handle different byte orders and not worry about the detail. Which isn&#39;t fun, right? So how might code to byte-swap a 32bit value look? Assuming you&#39;ve got the value as an actual numeric integer, it can be as simple as using a bit of bitwise anding and shifting. Here&#39;s the basic code I wrote in Common Lisp, for example: (defun swap-long (value) &#34;Swap the endianness of a long integer VALUE.&#34; (logior (logand (ash value -24) #xff) (logand (ash value -8) #xff00) (logand (ash value 8) #xff0000) (logand (ash value 24) #xff000000))) JavaScript might be something like: function swapLong( value ) { return ( ( value &gt;&gt; 24 ) &amp; 0xff ) | ( ( value &gt;&gt; 8 ) &amp; 0xff00 ) | ( ( value &lt;&lt; 8 ) &amp; 0xff0000 ) | ( ( value &lt;&lt; 24 ) &amp; 0xff000000 ) } and other variations on that theme in different languages. Up next In the next post I&#39;ll write about how the sequence index is stored and how to load it, including some considerations about how to make the loading as efficient as possible."/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://blog.davep.org/2020/08/30/reading-2bit-files-for-fun.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2020-08-30 15:20:00+01:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://blog.davep.org/author/dave-pearson.html">
  <meta property="article:section" content="Coding"/>
  <meta property="article:tag" content="Bioinformatics"/>
  <meta property="og:image" content="/static/davep.jpeg">

  <title>blog.davep.org &ndash; Reading 2bit files (for fun)</title>


</head>
<body >

<aside>
  <div>
    <a href="https://blog.davep.org/">
      <img src="/static/davep.jpeg" alt="davep" title="davep">
    </a>

    <h1>
      <a href="https://blog.davep.org/">davep</a>
    </h1>

    <p>Code, Emacs, VR, Stuff...</p>


    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://blog.davep.org/pages/about.html#about">
                About
              </a>
            </li>

          <li>
            <a target="_blank" href="http://davep.at/" >davep@</a>
          </li>
          <li>
            <a target="_blank" href="https://pinboard.in/u:davep" >Pinboard</a>
          </li>
          <li>
            <a target="_blank" href="https://seenbydavep.blogspot.com/" >Photoblog</a>
          </li>
          <li>
            <a target="_blank" href="https://elisp.dev/" >Emacs Packages</a>
          </li>
          <li>
            <a target="_blank" href="https://pypi.org/user/davepearson/" >Python Packages</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="https://github.com/davep"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-mastodon"
rel="me"           href="https://fosstodon.org/@davep"
           target="_blank">
          <i class="fa-brands fa-mastodon"></i>
        </a>
      </li>
      <li>
        <a class="sc-flickr"
           href="https://www.flickr.com/photos/davepearson/"
           target="_blank">
          <i class="fa-brands fa-flickr"></i>
        </a>
      </li>
      <li>
        <a class="sc-lastfm"
           href="https://www.last.fm/user/davepdotorg"
           target="_blank">
          <i class="fa-brands fa-lastfm"></i>
        </a>
      </li>
      <li>
        <a class="sc-npm"
           href="https://www.npmjs.com/~davep.org"
           target="_blank">
          <i class="fa-brands fa-npm"></i>
        </a>
      </li>
      <li>
        <a class="sc-youtube"
           href="https://www.youtube.com/user/daveporg"
           target="_blank">
          <i class="fa-brands fa-youtube"></i>
        </a>
      </li>
      <li>
        <a class="sc-steam"
           href="https://steamcommunity.com/id/davepdotorg"
           target="_blank">
          <i class="fa-brands fa-steam"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://blog.davep.org/">Home</a>

  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://blog.davep.org/feeds/all.atom.xml">Atom</a>

  <a href="https://blog.davep.org/feed.xml">RSS</a>
</nav>

<article class="single">
  <header>
      
    <h1 id="reading-2bit-files-for-fun">Reading 2bit files (for fun)</h1>
    <p>
      Posted on 2020-08-30 15:20 +0100 in <a href="https://blog.davep.org/category/coding.html">Coding</a>

        &#8226; 6 min read
    </p>
  </header>


  <div>
    <h1>Introduction</h1>
<p>I've written a bit before about the value of having simple but interesting
"problems", that you know the solution to, as <a href="/2019/11/10/going-on-a-journey.html">a way of exercising yourself
in a new environment</a>. Recently I've
added another to the list I already have, and I used it as an excuse to get
back into writing <a href="https://github.com/davep/org-davep-2bit">some Common
Lisp</a>; and then went on to use it
as a reason to write <a href="(https://elisp.dev/)">yet another</a> package <a href="https://github.com/davep/2bit.el">for
Emacs</a>.</p>
<p>Having gone through the process of writing code to handle 2bit files twice
in about a month, and in two very similar but slightly different languages,
I thought it might be interesting for me to then use it to exercise my
ability to write blog posts (something I always struggle with -- I find
writing <em>very hard</em> on a number of levels) and especially posts that explain
a particular problem and how I implemented code relating to that problem.</p>
<p>Also, because the initial version of this post rambled on a bit too much and
I lost the ability to finish it, I'm starting again and will be breaking it
up a number of posts spanning a number of days -- perhaps even weeks -- so
that I don't feel too overwhelmed by the process of writing it. I will, of
course, make sure every post links to the other posts.</p>
<p>Now, before I go on, I'll make the important point that everything here is
written from the perspective of a software developer who happens to work as
part of a bioinformatics team; I don't do bioinformatics, I don't claim to
understand it, I just happen to sit with (well, used to sit with them --
hopefully we'll all make it back to the office one day!) and work with them,
and develop software that supports their work. Anything you see in any of
the posts that's wrong about that subject: that's just my ignorance being
shown through the lens of a software developer (all corrections are
welcome).</p>
<p>So, with all those disclaimers aside, I'm going to go on a slow wander
through what a 2bit file is, how you'd go about reading it, and related
issues. This isn't designed as a tutorial or anything like that, this is
simply me taking what I've learnt and writing it down. Perhaps someone else
will benefit one day, but the purpose is to simply enjoy cementing it in my
own mind and to enjoy the process of putting it all in writing.</p>
<h1>What is a "2bit file"?</h1>
<p>So what's this new "problem" I've added to my list? It's code to read
sequence data from <a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format7">2bit format
files</a>. For anyone who
doesn't know (<em>bioinformatics people look away now; a software developer is
going to explain one of your file formats</em>), this is a file format that is
intended to hold sequences in an efficient way. As I'm sure you know,
<a href="https://en.wikipedia.org/wiki/DNA">DNA</a> is made up of <a href="https://en.wikipedia.org/wiki/Nucleobase">4
bases</a>, represented by the letters
<a href="https://en.wikipedia.org/wiki/Thymine"><code>T</code></a>,
<a href="https://en.wikipedia.org/wiki/Cytosine"><code>C</code></a>,
<a href="https://en.wikipedia.org/wiki/Adenine"><code>A</code></a> and
<a href="https://en.wikipedia.org/wiki/Guanine"><code>G</code></a>. So, in the simplest case, we
could just represent a genome using those four letters. Simple enough,
right? Nice big text file with just those 4 letters in?</p>
<p>The thing is, something like the human genome is around <a href="https://en.wikipedia.org/wiki/Human_genome#Molecular_organization_and_gene_content">3 billion bases in
length</a>.
That'd make for a petty big file to have to store and move around. So why
not compress it down a bit? That's where the 2bit format comes in.</p>
<p>Given this problem I'm sure most developers would quickly notice that, given
4 different characters, you only need 2 bits to actually hold them all (two
bits gets us <code>00</code>, <code>01</code>, <code>10</code> and <code>11</code>, so four different states). This
means with a little bit of coding you can store 4 bases in a single byte.
Just like that you've pretty much squished the whole thing down to 1/4 of
the original size. And that's more or less what the 2bit format does. If you
take a look at <a href="http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/">the actual data for the human
genome</a> you'll see
that <code>hg38.2bit</code> is roughly 1/4 of 3 billion bytes, ish, give or take.</p>
<p>There is a wrinkle, however. There are parts of a genome where you might not
know what base is there. Generally <a href="https://www.bioinformatics.org/sms/iupac.html">an <code>N</code> is used for
that</a>. So, actually, we want
to be able to store 5 different characters. But 5 isn't going to go into 2
bits... Damn! Well, it's okay, 2bit has a solution to that too, and I'll
cover that later on.</p>
<h1>How is a 2bit file formatted?</h1>
<p>As you can see from <a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format7">the format information available
online</a>, a 2bit file is
a binary file format that is split into 3 key parts:</p>
<ul>
<li>A fixed size header with some key information</li>
<li>An index into the rest of the file</li>
<li>A series of records that contain actual sequence information</li>
</ul>
<p>In this first post I'll cover the details of the header. Subsequent posts
will cover the index and the actual sequence data records.</p>
<h2>The header</h2>
<p>The header of a 2bit file is fixed in size and contains some key
information. It can be broken down as follows:</p>
<table>
<thead>
<tr>
<th>Content</th>
<th>Type</th>
<th>Size</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>Signature</td>
<td>Integer</td>
<td>4 bytes</td>
<td>See below for endian issues.</td>
</tr>
<tr>
<td>Version</td>
<td>Integer</td>
<td>4 bytes</td>
<td>Always 0.</td>
</tr>
<tr>
<td>Sequence count</td>
<td>Integer</td>
<td>4 bytes</td>
<td></td>
</tr>
<tr>
<td>Reserved</td>
<td>Integer</td>
<td>4 bytes</td>
<td>Always ignored.</td>
</tr>
</tbody>
</table>
<p>The signature value is used to test if what you're looking at is a 2bit
file, but also tells you some vital information about how to read the file
-- see below for more on that. The version value is always <code>0</code> -- as such
another useful test would be to error out if you get a valid signature but
get a version other than <code>0</code>. The sequence count is, as you'd guess, the
number of sequences that are held within the file -- this is important when
loading in the index of the file (more on that in the next post).</p>
<h2>The signature, big and little endianness, and byte swapping</h2>
<p>The header mentioned above comprises of 4 32-bit word values. The very first
word is important to how you read the rest of the file. This is the
<code>signature</code> for the 2bit file and it should always be <code>0x1A412743</code>. And this
is where it gets interesting and fun right away. The 2bit file format allows
for the fact that the file can be built in either <a href="https://en.wikipedia.org/wiki/Endianness">a little-endian or a
big-endian machine</a>, and the
32-bit word values can be binary-written to the file in the local
architecture's byte order. The effect of this is that, from reading the very
first value in the file, you need to decide if every other numeric value you
read needs to be byte-swapped in some way. The early logic being (in no
particular language) something like:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="nv">signature</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="nv">x1A412743</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nv">must_swap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">False</span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">byte_swap</span><span class="ss">(</span><span class="w"> </span><span class="nv">signature</span><span class="w"> </span><span class="ss">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="nv">x1A412743</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nv">must_swap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">True</span>
<span class="k">else</span>
<span class="w">  </span><span class="nv">raise</span><span class="w"> </span><span class="s2">&quot;This isn&#39;t a valid 2bit file&quot;</span>
<span class="k">end</span>
</code></pre></div>

<p>Simply put, to read the rest of the file you will need a function that
byte-swaps a 32bit numeric value, and a flag of some sort to mark that you
need to do this every time you read such a value. Of course, depending on
your language of choice, you could do it in a number of different ways. In a
language like JavaScript or Scheme, where you can easily throw around
functions, I'd probably just assign the appropriate 32bit-word-reading
function to a global function name and call that regardless throughout the
rest of the code. In other languages I'd probably just check the flag each
time and call the swapping function if needed. In something like Python I'd
likely just use the signature to decide on which format to pass to
<a href="https://docs.python.org/3.8/library/struct.html#struct.unpack"><code>struct.unpack</code></a>.
For example, some variation on:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Assuming that &#39;header&#39; is the whole header of the file read as a binary buffer.</span>

<span class="n">word_fmt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="k">for</span> <span class="n">test_fmt</span> <span class="ow">in</span> <span class="p">(</span> <span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;I&quot;</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span> <span class="n">test_fmt</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span> <span class="p">]</span> <span class="p">)[</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">==</span> <span class="mh">0x1A412743</span>
        <span class="n">word_fmt</span> <span class="o">=</span> <span class="n">test_fmt</span>
        <span class="k">break</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">word_fmt</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span> <span class="s2">&quot;This isn&#39;t a 2bit file&quot;</span> <span class="p">)</span>
</code></pre></div>

<p>Now, the Python approach sort of hides the important detail here. With it
we'd simply use <code>struct.unpack</code>'s <a href="https://docs.python.org/3.8/library/struct.html#byte-order-size-and-alignment">ability to handle different byte orders
</a>
and not worry about the detail. Which isn't fun, right? So how might code to
byte-swap a 32bit value look?</p>
<p>Assuming you've got the value as an actual numeric integer, it can be as
simple as using a bit of bitwise anding and shifting. Here's the basic code
I wrote in Common Lisp, for example:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">swap-long</span><span class="w"> </span><span class="p">(</span><span class="nv">value</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Swap the endianness of a long integer VALUE.&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nb">logior</span>
<span class="w">   </span><span class="p">(</span><span class="nb">logand</span><span class="w"> </span><span class="p">(</span><span class="nb">ash</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="mi">-24</span><span class="p">)</span><span class="w"> </span><span class="mh">#xff</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">logand</span><span class="w"> </span><span class="p">(</span><span class="nb">ash</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="mi">-8</span><span class="p">)</span><span class="w"> </span><span class="mh">#xff00</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">logand</span><span class="w"> </span><span class="p">(</span><span class="nb">ash</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="mh">#xff0000</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">logand</span><span class="w"> </span><span class="p">(</span><span class="nb">ash</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="mh">#xff000000</span><span class="p">)))</span>
</code></pre></div>

<p>JavaScript might be something like:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">swapLong</span><span class="p">(</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mf">24</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="w">       </span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">           </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w">  </span><span class="mf">8</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff00</span><span class="w">     </span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">           </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mf">8</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff0000</span><span class="w">   </span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">           </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mf">24</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff000000</span><span class="w"> </span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>and other variations on that theme in different languages.</p>
<h2>Up next</h2>
<p>In <a href="/2020/09/05/reading-2bit-files-for-fun-the-index.html">the next post</a>
I'll write about how the sequence index is stored and how to load it,
including some considerations about how to make the loading as efficient as
possible.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://blog.davep.org/tag/bioinformatics.html">Bioinformatics</a>
    </p>
  </div>






<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'blogdaveporg';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2015-2023 Dave Pearson</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://blog.davep.org/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="dark"
          type="text/javascript">
  </script>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " blog.davep.org ",
  "url" : "https://blog.davep.org",
  "image": "/static/davep.jpeg",
  "description": ""
}
</script>
</body>
</html>